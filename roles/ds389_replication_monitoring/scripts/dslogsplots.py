#!/usr/bin/python3
# --- BEGIN COPYRIGHT BLOCK ---
# Copyright (C) 2023 Red Hat, Inc.
# All rights reserved.
#
# License: GPL (version 3 or any later version).
# See LICENSE for details.
# --- END COPYRIGHT BLOCK ---

import datetime
import sys
import re
import argparse
import json
import logging
import matplotlib.pyplot as plt

class LagInfo:
    class CsnInfo:
        def __init__(self, csn):
            self.csn = csn
            self.oldest_time = None
            self.lag_time = None
            self.etime = None
            self.replicated_on = {}

        def json_parse(self, idx, json_dict):
            self.replicated_on[idx] = json_dict
            udt = json_dict['logtime']
            etime = float(json_dict['etime'])
            self._update_times(udt, etime, idx)

        def _update_times(self, udt, etime, idx):
            if self.oldest_time is None or self.oldest_time[0] > udt:
                self.oldest_time = [udt, idx]
            if self.lag_time is None or self.lag_time[0] < udt:
                self.lag_time = [udt, idx]
            if self.etime is None or self.etime[0] < etime:
                self.etime = [etime, idx]

        def resolve(self):
            self.lag_time[0] -= self.oldest_time[0]

        def __str__(self):
            return f'<CsnInfo: {self._to_dict()}>'

        def _to_dict(self):
            return {
                'csn': self.csn,
                'lag_time': self.lag_time,
                'etime': self.etime,
                'replicated_on': self.replicated_on
            }

    def __init__(self, args):
        self.args = args
        self.utc_offset = None
        self.log_files = None
        self.tz = None
        self.lag = []
        self.index_list = args.index if args.index else []
        self._setup_timezone()

    def _setup_timezone(self):
        if self.args.utc_offset:
            tz_delta = datetime.timedelta(seconds=self.args.utc_offset)
            self.tz = datetime.timezone(tz_delta)

    def date_from_udt(self, udt):
        try:
            return datetime.datetime.fromtimestamp(udt, tz=self.tz)
        except TypeError:
            return "?"

    def is_filtered(self, csninfo):
        if self.args.fully_replicated and len(self.index_list) != len(csninfo.replicated_on):
            return True
        if self.args.not_replicated and len(self.index_list) == len(csninfo.replicated_on):
            return True
        if self.args.lag_time and csninfo.lag_time[0] <= self.args.lag_time:
            return True
        if self.args.etime and csninfo.etime[0] <= self.args.etime:
            return True
        return False

    def json_parse(self, fd):
        json_dict = json.load(fd)
        self.utc_offset = json_dict["utc-offset"]
        self.log_files = json_dict["log-files"]
        if not self.args.index:
            self.index_list = list(range(len(self.log_files)))
        self._setup_timezone()
        for csn, csninfo in json_dict['lag'].items():
            info = LagInfo.CsnInfo(csn)
            for idx, record in csninfo.items():
                idx = int(idx)
                if idx in self.index_list:
                    info.json_parse(idx, record)
            info.resolve()
            if not self.is_filtered(info):
                self.lag.append(info)

    def plot_lag_image(self):
        self.lag.sort(key=lambda csninfo: csninfo.oldest_time[0])
        starting_time = self.date_from_udt(self.lag[0].oldest_time[0])

        xdata = [self.date_from_udt(i.oldest_time[0]) for i in self.lag]
        ydata = [i.lag_time[0] for i in self.lag]
        edata = [i.etime[0] for i in self.lag]

        if self.args.csv:
            with open(self.args.csv, "w", encoding="utf-8") as fd:
                fd.write("timestamp;lag;etime\n")
                for idx in range(len(xdata)):
                    fd.write(f"{xdata[idx]};{ydata[idx]};{edata[idx]}\n")

        plt.plot(xdata, ydata, label='lag')
        plt.plot(xdata, edata, label='etime')

        # Draw replication monitoring threshold line
        if self.args.replication_monitoring_threshold is not None:
            plt.axhline(y=self.args.replication_monitoring_threshold, color='r', linestyle='-', label='Replication Lag Threshold')

        plt.title('Replication lag time')
        plt.ylabel('time (s)')
        plt.xlabel(f'log time (starting on {starting_time})')
        plt.legend()

        if self.args.output:
            plt.savefig(self.args.output)
        else:
            plt.show()

def parse_arguments():
    parser = argparse.ArgumentParser(
        prog='dslogsplot',
        description='Plot data generated by dslogs.py -j ...'
    )
    parser.add_argument('-i', '--input', help="Input file (json)")
    parser.add_argument('-c', '--csv', help="Generate a CSV file (e.g., -c lag.csv)")
    parser.add_argument('-o', '--output', help="Generate an image (e.g., -o lag.png)")
    parser.add_argument('-f', '--fully-replicated', action="store_true", help="Filter out changes not replicated on all replicas")
    parser.add_argument('-n', '--not-replicated', action="store_true", help="Show only changes not replicated on all replicas")
    parser.add_argument('-l', '--lag-time', type=float, help="Show only changes with lag time >= value")
    parser.add_argument('-e', '--etime', type=float, help="Show only changes with etime >= value")
    parser.add_argument('-x', '--index', action="append", type=int, help="Ignore log files whose indexes are not specified")
    parser.add_argument('-u', '--utc-offset', type=int, help="UTC offset in seconds for timezone adjustment")
    parser.add_argument('-t', '--replication-monitoring-threshold', type=float, help="Replication monitoring threshold value")
    return parser.parse_args()

def main():
    args = parse_arguments()
    lag_info = LagInfo(args)
    with open(args.input, "r", encoding="utf-8") if args.input else sys.stdin as fd:
        lag_info.json_parse(fd)
    lag_info.plot_lag_image()

if __name__ == "__main__":
    main()
